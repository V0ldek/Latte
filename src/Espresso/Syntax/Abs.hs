{-# LANGUAGE DeriveFoldable #-}
module Espresso.Syntax.Abs where

import           Data.Hashable
import           Data.Int
import           Data.Maybe    (fromJust)

-- Haskell module generated by the BNF converter

class Positioned a where
  pos :: a -> Maybe Pos

unwrapPos :: Program (Maybe Pos) -> Program Pos
unwrapPos p = fromJust <$> p

type Pos = (Int, Int)
newtype SymIdent = SymIdent String deriving (Eq, Ord, Show, Read)
newtype LabIdent = LabIdent String deriving (Eq, Ord, Show, Read)
newtype ValIdent = ValIdent String deriving (Eq, Ord, Show, Read)
data QIdent a = QIdent a SymIdent SymIdent
  deriving (Eq, Ord, Show, Read, Foldable)

instance Functor QIdent where
    fmap f x = case x of
        QIdent a symident1 symident2 -> QIdent (f a) symident1 symident2
data Program a = Program a (Metadata a) [Method a]
  deriving (Eq, Ord, Show, Read, Foldable)

instance Functor Program where
    fmap f x = case x of
        Program a metadata methods -> Program (f a) (fmap f metadata) (map (fmap f) methods)
data Metadata a = Meta a [ClassDef a]
  deriving (Eq, Ord, Show, Read, Foldable)

instance Functor Metadata where
    fmap f x = case x of
        Meta a classdefs -> Meta (f a) (map (fmap f) classdefs)
data ClassDef a = ClDef a SymIdent [FieldDef a] [MethodDef a]
  deriving (Eq, Ord, Show, Read, Foldable)

instance Functor ClassDef where
    fmap f x = case x of
        ClDef a symident fielddefs methoddefs -> ClDef (f a) symident (map (fmap f) fielddefs) (map (fmap f) methoddefs)
data FieldDef a = FldDef a (SType a) SymIdent
  deriving (Eq, Ord, Show, Read, Foldable)

instance Functor FieldDef where
    fmap f x = case x of
        FldDef a stype symident -> FldDef (f a) (fmap f stype) symident
data MethodDef a = MthdDef a (FType a) (QIdent a)
  deriving (Eq, Ord, Show, Read, Foldable)

instance Functor MethodDef where
    fmap f x = case x of
        MthdDef a ftype qident -> MthdDef (f a) (fmap f ftype) (fmap f qident)
data FType a = FType a (SType a) [SType a]
  deriving (Eq, Ord, Show, Read, Foldable)

instance Functor FType where
    fmap f x = case x of
        FType a stype stypes -> FType (f a) (fmap f stype) (map (fmap f) stypes)
data SType a
    = Int a
    | Bool a
    | Void a
    | Arr a (SType a)
    | Cl a SymIdent
    | Ref a (SType a)
  deriving (Eq, Ord, Show, Read, Foldable)

instance Functor SType where
    fmap f x = case x of
        Int a         -> Int (f a)
        Bool a        -> Bool (f a)
        Void a        -> Void (f a)
        Arr a stype   -> Arr (f a) (fmap f stype)
        Cl a symident -> Cl (f a) symident
        Ref a stype   -> Ref (f a) (fmap f stype)
data Method a = Mthd a (SType a) (QIdent a) [Param a] [Instr a]
  deriving (Eq, Ord, Show, Read, Foldable)

instance Functor Method where
    fmap f x = case x of
        Mthd a stype qident params instrs -> Mthd (f a) (fmap f stype) (fmap f qident) (map (fmap f) params) (map (fmap f) instrs)
data Param a = Param a (SType a) ValIdent
  deriving (Eq, Ord, Show, Read, Foldable)

instance Functor Param where
    fmap f x = case x of
        Param a stype valident -> Param (f a) (fmap f stype) valident
data Instr a
    = ILabel a LabIdent
    | ILabelAnn a LabIdent Integer Integer
    | IVRet a
    | IRet a (Val a)
    | IOp a ValIdent (Val a) (Op a) (Val a)
    | ISet a ValIdent (Val a)
    | IStr a ValIdent String
    | IUnOp a ValIdent (UnOp a) (Val a)
    | IVCall a (Call a)
    | ICall a ValIdent (Call a)
    | INew a ValIdent (SType a)
    | INewArr a ValIdent (SType a) (Val a)
    | IJmp a LabIdent
    | ICondJmp a (Val a) LabIdent LabIdent
    | ILoad a ValIdent (Val a)
    | IStore a (Val a) (Val a)
    | IFld a ValIdent (Val a) (QIdent a)
    | IArr a ValIdent (Val a) (Val a)
    | IArrLen a ValIdent (Val a)
    | IPhi a ValIdent [PhiVariant a]
  deriving (Eq, Ord, Show, Read, Foldable)

instance Functor Instr where
    fmap f x = case x of
        ILabel a labident -> ILabel (f a) labident
        ILabelAnn a labident integer1 integer2 -> ILabelAnn (f a) labident integer1 integer2
        IVRet a -> IVRet (f a)
        IRet a val -> IRet (f a) (fmap f val)
        IOp a valident val1 op val2 -> IOp (f a) valident (fmap f val1) (fmap f op) (fmap f val2)
        ISet a valident val -> ISet (f a) valident (fmap f val)
        IStr a valident string -> IStr (f a) valident string
        IUnOp a valident unop val -> IUnOp (f a) valident (fmap f unop) (fmap f val)
        IVCall a call -> IVCall (f a) (fmap f call)
        ICall a valident call -> ICall (f a) valident (fmap f call)
        INew a valident stype -> INew (f a) valident (fmap f stype)
        INewArr a valident stype val -> INewArr (f a) valident (fmap f stype) (fmap f val)
        IJmp a labident -> IJmp (f a) labident
        ICondJmp a val labident1 labident2 -> ICondJmp (f a) (fmap f val) labident1 labident2
        ILoad a valident val -> ILoad (f a) valident (fmap f val)
        IStore a val1 val2 -> IStore (f a) (fmap f val1) (fmap f val2)
        IFld a valident val qident -> IFld (f a) valident (fmap f val) (fmap f qident)
        IArr a valident val1 val2 -> IArr (f a) valident (fmap f val1) (fmap f val2)
        IArrLen a valident val -> IArrLen (f a) valident (fmap f val)
        IPhi a valident phivariants -> IPhi (f a) valident (map (fmap f) phivariants)
data PhiVariant a = PhiVar a LabIdent (Val a)
  deriving (Eq, Ord, Show, Read, Foldable)

instance Functor PhiVariant where
    fmap f x = case x of
        PhiVar a labident val -> PhiVar (f a) labident (fmap f val)
data Call a
    = Call a (SType a) (QIdent a) [Val a]
    | CallVirt a (SType a) (QIdent a) [Val a]
  deriving (Eq, Ord, Show, Read, Foldable)

instance Functor Call where
    fmap f x = case x of
        Call a stype qident vals -> Call (f a) (fmap f stype) (fmap f qident) (map (fmap f) vals)
        CallVirt a stype qident vals -> CallVirt (f a) (fmap f stype) (fmap f qident) (map (fmap f) vals)
data Val a
    = VInt a Integer
    | VNegInt a Integer
    | VTrue a
    | VFalse a
    | VNull a (SType a)
    | VVal a (SType a) ValIdent
  deriving (Eq, Ord, Show, Read, Foldable)

instance Functor Val where
    fmap f x = case x of
        VInt a integer        -> VInt (f a) integer
        VNegInt a integer     -> VNegInt (f a) integer
        VTrue a               -> VTrue (f a)
        VFalse a              -> VFalse (f a)
        VNull a stype         -> VNull (f a) (fmap f stype)
        VVal a stype valident -> VVal (f a) (fmap f stype) valident
data Op a
    = OpAdd a
    | OpSub a
    | OpMul a
    | OpDiv a
    | OpMod a
    | OpLTH a
    | OpLE a
    | OpGTH a
    | OpGE a
    | OpEQU a
    | OpNE a
  deriving (Eq, Ord, Show, Read, Foldable)

instance Functor Op where
    fmap f x = case x of
        OpAdd a -> OpAdd (f a)
        OpSub a -> OpSub (f a)
        OpMul a -> OpMul (f a)
        OpDiv a -> OpDiv (f a)
        OpMod a -> OpMod (f a)
        OpLTH a -> OpLTH (f a)
        OpLE a  -> OpLE (f a)
        OpGTH a -> OpGTH (f a)
        OpGE a  -> OpGE (f a)
        OpEQU a -> OpEQU (f a)
        OpNE a  -> OpNE (f a)
data UnOp a = UnOpNeg a | UnOpNot a
  deriving (Eq, Ord, Show, Read, Foldable)

instance Functor UnOp where
    fmap f x = case x of
        UnOpNeg a -> UnOpNeg (f a)
        UnOpNot a -> UnOpNot (f a)

isLabel :: Instr a -> Bool
isLabel instr = case instr of
  ILabel {}    -> True
  ILabelAnn {} -> True
  _            -> False

isPhi :: Instr a -> Bool
isPhi instr = case instr of
    IPhi {} -> True
    _       -> False

instance Hashable (Val a) where
    hashWithSalt salt val = case val of
        VInt _ n               -> hashWithSalt salt (0 :: Int8, n)
        VNegInt _ n            -> hashWithSalt salt (0 :: Int8, -n)
        VTrue _                -> hashWithSalt salt (1 :: Int8, True)
        VFalse _               -> hashWithSalt salt (1 :: Int8, False)
        VNull _ _              -> hashWithSalt salt (2 :: Int8, False)
        VVal _ _ (ValIdent vi) -> hashWithSalt salt (3 :: Int8, vi)

instance Hashable (Op a) where
    hashWithSalt salt val = case val of
        OpAdd _ -> hashWithSalt salt (0 :: Int8)
        OpSub _ -> hashWithSalt salt (1 :: Int8)
        OpMul _ -> hashWithSalt salt (2 :: Int8)
        OpDiv _ -> hashWithSalt salt (3 :: Int8)
        OpMod _ -> hashWithSalt salt (4 :: Int8)
        OpLTH _ -> hashWithSalt salt (5 :: Int8)
        OpLE _  -> hashWithSalt salt (6 :: Int8)
        OpGTH _ -> hashWithSalt salt (7 :: Int8)
        OpGE _  -> hashWithSalt salt (8 :: Int8)
        OpEQU _ -> hashWithSalt salt (9 :: Int8)
        OpNE _  -> hashWithSalt salt (10 :: Int8)

instance Hashable (UnOp a) where
  hashWithSalt salt val = case val of
    UnOpNeg _ -> hashWithSalt salt False
    UnOpNot _ -> hashWithSalt salt True

instance Hashable SymIdent where
  hashWithSalt salt (SymIdent s) = hashWithSalt salt s

instance Hashable ValIdent where
  hashWithSalt salt (ValIdent s) = hashWithSalt salt s
